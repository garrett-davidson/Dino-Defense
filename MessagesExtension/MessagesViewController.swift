//
//  MessagesViewController.swift
//  MessagesExtension
//
//  Created by Garrett Davidson on 10/21/16.
//  Copyright Â© 2016 Garrett Davidson. All rights reserved.
//

import UIKit
import Messages
import SpriteKit

class MessagesViewController: MSMessagesAppViewController, UICollectionViewDelegate, UICollectionViewDataSource {
    var newImageView = UIImageView()

    @IBOutlet weak var towerMenuView: UIView!
    @IBOutlet weak var addButton: UIButton!
    @IBOutlet weak var deleteButton: UIButton!
    @IBOutlet weak var gameView: SKView!
    @IBOutlet weak var collection: UICollectionView!
    @IBOutlet weak var startGame: UIButton!
    @IBAction func clickStart(_ sender: AnyObject) {

        requestPresentationStyle(.expanded)

    }

    var gameScene: GameScene!

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }

    func loadGameScene() {

        if let scene = SKScene(fileNamed: "MapScene") as? GameScene {
            self.gameScene = scene
            scene.scaleMode = .fill

            gameView.presentScene(scene)
            gameView.isHidden = true
        }

        gameView.ignoresSiblingOrder = true

        gameView.showsFPS = true
        gameView.showsNodeCount = true
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    // MARK: - Conversation Handling

    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.

        // Use this method to configure the extension and restore previously stored state.
    }

    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.

        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }

    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.

        // Use this method to trigger UI updates in response to the message.
    }

    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }

    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.

        // Use this to clean up state related to the deleted message.
    }

    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.

        // Use this method to prepare for the change in presentation style.
    }

    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.

        // Use this method to finalize any behaviors associated with the change in presentation style.
        if presentationStyle == .expanded {
            loadGameScene()
            collection.isHidden = false
            towerMenuView.isHidden = false
            gameView.isHidden = false
            gameScene.isHidden = false
            gameScene.placeTestCantaloupe()
        }
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return 8
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        guard let cell = collection.dequeueReusableCell(withReuseIdentifier: "TowerCollectionViewCell", for: indexPath) as? TowerCollectionViewCell else {
            fatalError("could not find the cell of correct type.")
        }

        guard let image = UIImage(named: "Cantaloupe") else {

            print("no image")
            return cell
        }
        cell.towerImage.image = image
        return cell
    }
    func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) {
        collectionView.isUserInteractionEnabled = false
        guard let tower = collection.cellForItem(at: indexPath) as? TowerCollectionViewCell else {
            fatalError("could not find the cell of correct type.")
        }

        let image = tower.towerImage.image

        newImageView = UIImageView(image: image)
        newImageView.isUserInteractionEnabled = true
        newImageView.isMultipleTouchEnabled = true
        newImageView.isExclusiveTouch = true
        newImageView.contentMode = .scaleToFill

        let panGesture = UIPanGestureRecognizer(target: self, action:#selector(myPanAction))
        newImageView.addGestureRecognizer(panGesture)
        newImageView.frame = self.view.bounds
        newImageView.frame.size.width = 32
        newImageView.frame.size.height = 32
        newImageView.center.y = self.view.frame.height/2
        newImageView.center.x = self.view.frame.width/2
        self.view.addSubview(newImageView)
        self.view.bringSubview(toFront: newImageView)

    }

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        print("clicked")

    }

    func myPanAction(recognizer: UIPanGestureRecognizer) {
        let translation = recognizer.translation(in: self.view)
        if let myView = recognizer.view {
            myView.center = CGPoint(x: myView.center.x + translation.x, y: myView.center.y + translation.y)
        }
        recognizer.setTranslation(CGPoint(x: 0, y: 0), in: self.view)

    }
}
